B <- matrix(c(3,0,0,2), nrow = 2, ncol = 2)
B
norm(B, type = c("2"))
norm(A, type = c("2"))
sqrt(4)
(2*sqrt(2))^2
x <- c(1,2)
x %*% t(x)
library(rstanarm)
library(tidyverse)
# Load data
hibbs <- read.table(file = "~/developer/regression_stories/ROS-Examples/ElectionsEconomy/data/hibbs.dat", header = TRUE)
plot(hibbs$growth, hibbs$vote, xlab = "Economic growth",
ylab = "Incumbent party's vote share")
# Fit and display a regression model with a single predictor
M1 <- stan_glm(vote ~ growth, data = hibbs)
print(M1)
# Access the simulations used to build the model
sims <- as.matrix(M1)
sims
# Compute parameters directly
Media <- apply(sims, 2, median)
MAD_SD <- apply(sims, 2, mad)
MAD_SD
Media
print(M1)
print(cbind(Median, MAD_SD))
rm(Media)
# Compute parameters directly
Median <- apply(sims, 2, median)
MAD_SD <- apply(sims, 2, mad)
print(cbind(Median, MAD_SD))
print(M1)
# Point prediction of model
# Create a new dataset with the hypothetical value of x
new <- data.frame(growth = 2.0)
new
# Compute point prediction
y_point_pred <- predict(M1, newdata = new)
y_point_pred
# Compute point prediction
y_point_pred <- predict(M1, newdata = new)
y_point_pred
coef(M1)
y_point_pred_man <- a_hat + b_hat*new
# Manually point predict
a_hat <- coef(M1)[1]
b_hat <- coef(M1)[2]
y_point_pred_man <- a_hat + b_hat*new
y_point_pred_man
# Compute linear predictor with uncertainty
posterior_linpred(M1, newdata = new)
1/0.08
abs((1/14)-(1/13))
abs((1/13)-(1/14))
abs((1/13)-(1/12))
abs((1/11)-(1/12))
source('~/.active-rstudio-document', echo=TRUE)
1/0.0015
1/0.001562
sherlock_raw <- gutenberg_download(1661)
library(tidyverse)
library(gutenbergr)
library(tidytext)
library(tm)
sherlock_raw <- gutenberg_download(1661)
sherlock <- sherlock_raw %>%
mutate(story = ifelse(str_detect(text, "ADVENTURE"),
text,
NA)) %>%
fill(story) %>%
filter(story != "THE ADVENTURES OF SHERLOCK HOLMES") %>%
mutate(story = factor(story, levels = unique(story)))
sherlock
scandal_in_bohemia <- sherlock %>%
filter(story == "ADVENTURE I. A SCANDAL IN BOHEMIA" & text != "")
scandal_in_bohemia
# Obtain the text for scandal in bohemia
scandal_in_bohemia_text <- scandal_in_bohemia$text
scandal_in_bohemia_text
View(scandal_in_bohemia)
scandal_in_bohemia[366]
scandal_in_bohemia[,366]
scandal_in_bohemia$text[366]
# Replace Mr., Mrs. and Dr. with Mr, Mrs, and Dr
scandal_in_bohemia_text_lower <- str_to_lower(scandal_in_bohemia_text)
scandal_in_bohemia_text_lower <- str_replace(scandal_in_bohemia_text_lower, pattern = "mrs\\.", replacement =  "mrs")
scandal_in_bohemia_text_lower <- str_replace(scandal_in_bohemia_text_lower, pattern = "mr\\.", replacement =  "mr")
scandal_in_bohemia_text_lower <- str_replace(scandal_in_bohemia_text_lower, pattern = "dr\\.", replacement =  "dr")
# Concatenate the text
scandal_in_bohemia_text_concat <- paste(scandal_in_bohemia_text_lower, collapse = ' ')
scandal_in_bohemia_text_concat
scandal_in_bohemia_text_lower
scandal_in_bohemia_text_lower[366]
as.roman(2)
typeof(as.roman(2))
class(as.roman(2))
as.character(as.roman(2))
str_c(as.character(as.roman(2)), ".")
str_to_lower(str_c(as.character(as.roman(2)), "."))
?rbinom
n_girls <- rbinom(n = 1, size = 400, prob = 0.488)
n_girls
n_girls
n_girls <- rep(NA, n_sims)
# Simulate the process 1000 times
n_sims <- 1000
n_girls <- rep(NA, n_sims)
n_girls
n_sims <- 1000
n_girls <- rep(NA, n_sims)
for (s in 1:n_sims) {
n_girls[s] <- rbinom(n = 1, size = 400, prob = 0.488)
}
hist(n_girls)
# Simulate from the binomial distribution directly
n_girls <- rbinom(n = 1000, size = 400, prob = 0.488)
# Bootstrapping
# Bootstrapping ratio of female to male earnings
earnings <- read.csv(file = "~/developer/regression_stories/ROS-Examples/Earnings/data/earnings.csv")
earning$earn
earnings$earn
earn <- earnings$earn
male <- earnings$male
ratio <- median(earn[male == 0])/ median(earn[male == 1])
ratio
# To generate bootstrap replicates, first wrap bootstrap ratio as a function
n <- nrow(earnings)
boot <- sample(n, replace = TRUE)
boot
n
earn_boot <- earn[boot]
male_boot <- male[boot]
earn_boot
earn_boot[male_boot == 0]
male_boot
ratio_boot <- median(earn_boot[male_boot == 0])/ median(earn_boot[male_boot == 1])
# To generate bootstrap replicates, first wrap the single bootstrap ratio replicate as a function
boot_ratio <- function(data) {
n <- nrow(earnings)
boot <- sample(n, replace = TRUE)
earn_boot <- earn[boot]
male_boot <- male[boot]
ratio_boot <- median(earn_boot[male_boot == 0])/ median(earn_boot[male_boot == 1])
return(ratio_boot)
}
output <- replicate(n_sims, boot_ratio(data = earnings))
# Generate multiple bootstrap replicates
n_sims <- 10000
output <- replicate(n_sims, boot_ratio(data = earnings))
hist(output)
# Generate multiple bootstrap replicates
n_sims <- 10000
output <- replicate(n_sims, boot_ratio(data = earnings))
hist(output)
sd(output)
output
library(rstanarm)
# Simulate fake data from a regression model
x <- 1:20
n <- length(x)
a <- 0.2 # intercept
b <- 0.3 # coefficient of x
sigma <- 0.5 #standard deviation
y <- a + b*x + sigma*rnorm(n) # Error is N(0, 0.5)
y
# Fit a regression and display the results
fake <- data.frame(x, y)
fake
fit_1 <- stan_glm(y ~ x, data = fake)
fit_1
print(fit_1)
plot(fake$x, fake$y, main = "Data and fitted regression line")
a_hat <- coef(fit_1)[1]
b_hat <- coef(fit_1)[2]
b_hat
abline(a_hat, b_hat)
a_hat
x_bar <- mean(fake$x)
text(x_bar, a_hat + b_hat*x_bar,
paste("y =", round(a_hat, 2), "+", round(b_hat, 2), "*x"), adj = 1)
text(x_bar, a_hat + b_hat*x_bar,
paste("y =", round(a_hat, 2), "+", round(b_hat, 2), "*x"), adj = 0)
plot(fake$x, fake$y, main = "Data and fitted regression line")
abline(a_hat, b_hat)
text(x_bar, a_hat + b_hat*x_bar,
paste("y =", round(a_hat, 2), "+", round(b_hat, 2), "*x"), adj = 0)
# Interpreting coefficients as comparisons
earnings$earnk
# Interpreting coefficients as comparisons
## Fit a model to the earnings data
earnings$earnk <- earnings$earn/1000
fit_2 <- stan_glm(earnk ~ height + male, data = earnings)
print(fit_2)
## Residual standard deviation is 21.4 and since the earnk is in 1000s of dollars, this indicates that earnings will be within + or - 21 400 for 68% of the data
## Compute R^2
R2 <- 1 - sigma(fit_2)^2/ sd(earnings$earnk)^2
R2
n <- 1000
true_ability <- rnorm(n, 50, 10) # True ability is generated from this distribution for each student
noise_1 <- rnorm(n, 0, 10)
noise_1 <- rnorm(n, 0, 10)
midterm <- true_ability + noise_1
final <- true_ability + noise_2
exams <- data.frame(midterm, final)
n <- 1000
true_ability <- rnorm(n, 50, 10) # True ability is generated from this distribution for each student
noise_1 <- rnorm(n, 0, 10)
noise_2 <- rnorm(n, 0, 10)
midterm <- true_ability + noise_1
final <- true_ability + noise_2
exams <- data.frame(midterm, final)
fit_1 <- stan_glm(final ~ midterm, data = exams)
plot(midterm, final, xlab = "Midterm exam score", ylab = "Final exam score")
abline(coef(fit_1))
abline(coef(fit_1), col = "red")
print(fit_1)
# Load in Hibbs Election data
hibbs <- read.csv(file = "~/developer/regression_stories/ROS-Examples/ElectionsEconomy/data/hibbs.dat")
# Load in Hibbs Election data
hibbs <- read.csv(file = "~/developer/regression_stories/ROS-Examples/ElectionsEconomy/data/hibbs.dat", header = TRUE)
hibbs
hibbs$growth
# Load in Hibbs Election data
hibbs <- read.table(file = "~/developer/regression_stories/ROS-Examples/ElectionsEconomy/data/hibbs.dat", header = TRUE)
# Plot the data
plot(hibbs$growth)
hibbs
# Plot the data
plot(hibbs$growth, hibbs$vote, xlab = "Economic growth",
ylab = "Incumbent party's vote share")
# Fit and display a regression model
M1 <- stan_glm(vote ~ growth, data = hibbs)
print(M1)
# Plot the fitted regression line
abline(coef(M1))
# Pretend the fitted particular parameter values are the truth
coef(M1)
# Pretend the fitted particular parameter values are the truth
print(M1)
a <- 46.2
b <- 3.1
sigma <- 3.9
x <- hibbs$growth
n <- length(x)
# Simulate a vector y of fake data and put this in a dataframe
y <- a + b*x + rnorm(n, 0, sigma) #errors are normally distributed
fake <- data.frame(x, y)
# Fit the model and compare fitted to assumed values
fit <- stan_glm(y ~ x, data = fake)
print(fit)
coef(fit)
# Compare coefficients and standard error - for ease, look at slope only
b_hat <- coef(fit)['x']
se(fit)
b_se <- se(fit)['x']
abs(b - b_hat) < b_se
abs(b - b_hat)
b_se
cover_68 <- abs(b - b_hat) < b_se
cover_95 abs(b - b_hat) < 2+b_se
cat(paste("68% coverage: ", cover_68, "\n"))
cat(paste("95% coverage: ", cover_95, "\n"))
cover_68 <- abs(b - b_hat) < b_se
cover_95 <- abs(b - b_hat) < 2+b_se
cat(paste("68% coverage: ", cover_68, "\n"))
cat(paste("95% coverage: ", cover_95, "\n"))
n_fake <- 1000
cover_68 <- rep(NA, fake)
cover_95 <- rep(NA, fake)
t_68 <- qt(0.84, n - 2)
t_95 <- qt(0.975, n - 2)
for (s in 1:n_fake) {
y <- a + b*x + rnorm(n, 0, sigma)
fake <- data.frame(x, y)
fit <- stan_glm(y ~ x, data = fake, refresh = 0)
b_hat <- coef(fit)['x']
b_se <- se(fit)['x']
cover_68[s] <- abs(b - b_hat) < t_68 * b_se
cover_95[s] <- abs(b - b_hat) < t_95 * b_se
}
cat(paste("68% coverage: ", mean(cover_68), "\n"))
cat(paste("95% coverage: ", mean(cover_95), "\n"))
x <- seq(0,100,length.out = 100)        # independent variable
sig <- 0.1 + 0.05*x                     # non-constant variance
b_0 <- 6                                # true intercept
b_1 <- 0.1                              # true slope
set.seed(1)                             # make the next line reproducible
e <- rnorm(100,mean = 0, sd = sig)      # normal random error with non-constant variance
y <- b_0 + b_1*x + e                    # dependent variable
dat <- data.frame(x,y)
# Quantile Regression
library(ggplot2)
ggplot(dat, aes(x,y)) + geom_point()
# Plot a linear regression line
ggplot(data = dat, mapping = aes(x,y)) + geom_point() + geom_smooth(method = "lm")
# Consider a line which plots the 0.9 quantile (90% of observations are beneath it)
ggplot(data  = dat, mapping = aes(x, y)) +
geom_point() +
geom_quantile(quantiles = 0.9)
library(quantreg)
# To perform quantile regression
qrl <- rq(y ~ x, data = dat, tau = 0.9)
qrl
## Perform regression for more than one quantile
qs <- 1:9/10
qs
qr2 <- rq(y ~ x, data = dat, tau = qs)
summary(qr2)
coef(qr2)
ggplot(data = dat, mapping = aes(x, y)) +
geom_point() +
geom_quantile(quantiles = qs)
2/6
3/6
install.packages("quantregForest")
library(quantregForest)
data("airquality")
# remove observations with missing values
airquality <- airquality[!apply(is.na(airquality), 1, any),]
airquality
head(airquality)
# number of remaining samples
n <- nrow(airquality)
# divide into training and test data
indextrain <- sample(1:n, round(0.6*n), replace = FALSE)
Xtrain <- airquality[indextrain, 2:6]
Xtest <- airquality[-indextrain, 2:6]
Ytrain <- airquality[indextrain, 1]
Ytest <- airquality[-indextrain, 1]
# Compute quantile regression forests
qrf <- quantregForest(x = Xtrain, y = Ytrain)
qrf
# Compute quantile regression forests
qrf <- quantregForest(x = Xtrain, y = Ytrain, nodesize = 10, sampsize = 30)
qrf
predict(qrf, Xtest)
# predict 0.1, 0.5, 0.9 quantiles for test data
conditionalQuantiles <- predict(qrf, Xtest)
print(conditionalQuantiles[1:4,])
?predict
# predict 0.1, 0.2,..., 0.9 quantiles for test data - call quantiles separated by 0.1 increments
conditionalQuantiles <- predict(qrf, Xtest, what = 0.1 * (1:9))
print(conditionalQuantiles[1:4,])
# Estimare conditional standard deviation
conditionalsd <- predict(qrf, Xtest, what = sd)
conditionalsd
# Estimate conditional mean (like in the original Random Forest)
conditionalMean <- predict(qrf, Xtest, what = mean)
print(conditionalMean[1:4,])
print(conditionalMean[1:4])
predict(qrf, Xtest, what = median)
predict(qrf, Xtest, what = 0.5)
predict(qrf, Xtest, what = median) == predict(qrf, Xtest, what = 0.5)
nrow(Xtest) == sum(predict(qrf, Xtest, what = median) == predict(qrf, Xtest, what = 0.5))
# sample 10 new observations from conditional distribution at each new sample
newSamples <- predict(qrf, Xtest, what = function(x) {sample(x, 10, replace = TRUE)})
x
print(newSamples[1:4,])
print(conditionalQuantiles[1:4,])
Xtest
Ytest
conditionalQuantiles[1,]
conditionalQuantiles[,1]
conditionalQuantiles[,1] %in% Ytrain
conditionalQuantiles[!(conditionalQuantiles[,1] %in% Ytrain), 1]
library(reticulate)
repl_python()
library(rstanarm)
library(Rcpp)
library(rstanarm)
install.packages("Rcpp")
install.packages("rstanarm")
install.packages("Rcpp")
library(rstanarm)
library(rstanarm)
install.packages("Rcpp")
library(Rcpp)
sessionInfo()
library(Rcpp)
library(rstanarm)
lincomb <- function(x1, x2, x3) {
constants <- c(2, 4, 7)
x <- c(x1, x2, x3)
y <- constants %*% x
return(y)
}
lincomb(1, 1, 1)
2+4+7
2*lincomb(1, 1, 1)
(2 * lincomb(1, 1, 1)) + 5
(2lincomb(1, 1, 1))
lincomb2 <- function(x1, x2, x3) {
constants <- c(2, 4, 6)
x <- c(x1, x2, x3)
y <- constants %*% x
return(y)
}
(2*lincomb(1, 1, 1)) + (3*lincomb2(1, 1, 1))
lincomb2(1, 1, 1)
(3*lincomb2(1, 1, 1))
(2*lincomb(1, 1, 1))
setwd("~/Developer/r_plumber/r_quickstart")
library(plumber)
install.packages("plumber")
getwd()
library(plumber)
root <- pr("plumber.R")
root %>% pr_run()
root %>% pr_run()
root <- pr("plumber.R")
root %>% pr_run()
#* @ApiTitle Conditionally sum numbers
#* @get /sum
function(a, b) {
a <- as.numeric(a)
b <- as.numeric(b)
c <- sum(a, b)
return(c)
}
library(plumber)
root <- pr("plumber.R")
root %>% pr_run()
root <- pr("plumber.R")
root %>% pr_run()
req$username
library(jsonlite)
toJSON(list(a=1, b=1, username='foo'))
list(a=1, b=1, username='foo')
toJSON(list(a=1, b=1, username='foo'))
root %>% pr_run()
plumber::forward()
root <- pr("plumber.R")
root %>% pr_run()
fromJSON(txt = '{"a":1,"b":2,"username":"foo}')
fromJSON(txt = '{a:1,b:2,"username":"foo}')
fromJSON(txt = "{a:1,b:2,"username":"foo}"")
fromJSON(txt = "{a:1,b:2,"username":"foo}")
fromJSON(txt = "{a:1,b:2,username:foo}")
?fromJSON
fromJSON(txt = '{"city" : "Z\\u00FCrich"}')
fromJSON(txt = '{"a" : "1"}')
fromJSON(txt = '{"a" : "1", "b":2}')
fromJSON(txt = '{"a" : 1, "b": 2, "username": Junaid}')
fromJSON(txt = '{"a" : 1, "b": 2, "username": "Junaid"}')
root <- pr("plumber.R")
root %>% pr_run()
fromJSON('{"a":1,"b":1,"username":"foo"}')
root <- pr("plumber.R")
root %>% pr_run()
a
fromJSON('{"a":1,"b":1,"username":"foo"}')
foo <- fromJSON('{"a":1,"b":1,"username":"foo"}')
foo$username
root <- pr("plumber.R")
root %>% pr_run()
root <- r("plumber.R")
root %>% pr_run()
root <- r("plumber.R")
root %>% pr_run()
root <- r("plumber.R")
root %>% pr_run()
foo <- fromJSON('{"a":1, "b": "2", "username": "Junaid"}')
foo
root <- r("plumber.R")
root %>% pr_run()
toJSON(list(a=1, b=1, username='foo'))
jsonlite::toJSON(list(a=1, b=1, username='foo'))
root <- r("plumber.R")
root %>% pr_run()
root <- r("plumber.R")
root %>% pr_run()
jsonlite::toJSON(iris[1,])
list(a = 1, b = 2, username = Junaid)
list(a = 1, b = 2, username = 'Junaid')
jsonlite::toJSON(list(a = 1, b = 2, username = 'Junaid'))
list(list(a = 1), b = 2, username = 'Junaid')
root <- r("plumber.R")
root %>% pr_run()
root <- r("plumber.R")
root %>% pr_run(host=8000)
?pr_run()
root <- r("plumber.R")
root %>% pr_run(port=8000)
root <- r("~/developer/r_plumber/r_quickstart/plumber.R")
root <- r("~/developer/r_plumber/r_quickstart/plumber.R")
root <- pr("~/developer/r_plumber/r_quickstart/plumber.R")
root %>% pr_run(port=8000)
root <- pr("~/developer/r_plumber/r_quickstart/plumber.R")
root %>% pr_run(port=8000)
jsonlite::toJSON(id=123&name=Jennifer)
jsonlite::toJSON("id=123&name=Jennifer")
root <- pr("~/developer/r_plumber/r_quickstart/plumber.R")
root %>% pr_run(port=8000)
root <- pr("~/developer/r_plumber/r_quickstart/plumber.R")
root %>% pr_run(port=8000)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
library(plumber)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
packageVersion("plumber")
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000)
root <- plumb("~/developer/r_plumber/r_quickstart/plumber.R")
root$run(port=8000, swagger = TRUE)
